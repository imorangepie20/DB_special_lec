# 초롱대학교 데이터베이스 특강

## 제 7강: 데이터 요약하기, 그룹화와 집계 함수 (GROUP BY)

6강 마지막 질문의 정답입니다! 6,000명의 개별 학생 데이터를 18개의 '학과별'로 묶어서 학생 수 통계를 내고 싶을 때 사용하는 특별한 구문은 바로 **`GROUP BY`** 입니다.

수많은 데이터를 요약하고 분석하여 비즈니스 인사이트(통계)를 뽑아내는, 데이터 과학과 분석의 가장 기초가 되는 문법을 배워보겠습니다.

---

### 1. 데이터를 묶는 마법의 키워드: `GROUP BY`

**`GROUP BY`**는 말 그대로 데이터를 특정 기준(컬럼)에 따라 그룹으로 묶어주는 역할을 합니다.

"학생 테이블을 '학과코드' 기준으로 묶어줘!" 라고 한다면 학생 데이터 6,000줄이 18줄(초롱대학교의 총 학과 수)로 압축되면서 각각의 덩어리로 나뉘게 됩니다.

### 2. 그룹과 찰떡궁합: 집계 함수 (Aggregate Functions)

데이터를 묶기만 해서는 의미가 없습니다. 묶어놓은 덩어리(그룹) 안에서 계산을 해야 비로소 통계가 완성됩니다. 이 계산을 해주는 함수들을 **집계 함수**라고 합니다.

* **`COUNT()`:** 건수(개수)를 세어줍니다. (예: 학생 수)
* **`SUM()`:** 합계를 내줍니다.
* **`AVG()`:** 평균을 구해줍니다. (예: 학과별 학생들의 평균 학년)
* **`MAX()`:** 최댓값을 찾습니다.
* **`MIN()`:** 최솟값을 찾습니다.

#### 실습 1) 초롱대학교 각 학과별 학생 수 구하기
```sql
SELECT 
    department_code,          -- 기준이 되는 학과코드
    COUNT(student_id) AS student_count  -- 그 학과에 속한 학생(학번) 수를 세어라! (student_count라는 별명 붙임)
FROM Student
GROUP BY department_code;     -- "학과코드 별로 묶어라"
```
* 위 결과를 실행하면 `CS01` 코드는 학생 수 320명, `EE02` 코드는 290명 등등, 통계 데이터가 출력됩니다.

### 3. 그룹핑 된 결과에 조건을 걸고 싶을 때: `HAVING`

자, 교수님께서 방금 뽑아온 학과별 학생 수 통계표를 보시더니 새로운 지시를 내리십니다.
*"학생 수가 너무 적은 학과는 통폐합 위기일세. **학생 수가 100명 미만인 학과들만** 다시 추려서 가져오게!"*

어? 조건 검색은 5강에서 배운 `WHERE` 절을 쓰면 되지 않나요?

>**🚨 초특급 주의사항:**
>**`WHERE` 절 안에서는 `COUNT()` 같은 집계 함수를 절대 사용할 수 없습니다!** 
>`WHERE`는 그룹으로 묶이기 전(날것의 원본 데이터) 단계에서 필터링을 하는 녀석이기 때문입니다.

그룹핑이 끝난 뒤에, 그 그룹 함수 결과(집계된 값)를 가지고 필터링을 하려면 **`HAVING`** 이라는 키워드를 써야 합니다.

#### 실습 2) 학생 수가 100명 미만인 위기의 학과 찾기
```sql
SELECT 
    department_code, 
    COUNT(student_id) AS student_count
FROM Student
GROUP BY department_code       -- 1. 먼저 학과코드로 묶고 집계한다.
HAVING COUNT(student_id) < 100; -- 2. 묶인 결과(학생 수)가 100명 미만인 그룹만 통과시킨다.
```

---

### 4. SQL 쿼리의 실행 순서 (마법의 6단계)

이제 여러 문법을 배웠으니 헷갈리지 않게 SQL이 어떻게 작동하는지 순서를 외워둘 필요가 있습니다. 작성 순서와 실제 컴퓨터가 처리하는 순서는 완전히 다릅니다!

* **작성 순서:** `SELECT` ➜ `FROM` ➜ `WHERE` ➜ `GROUP BY` ➜ `HAVING` ➜ `ORDER BY`(정렬)
* **실제 컴퓨터의 처리 순서 (암기 필수!)**
  1. **`FROM` / `JOIN`:** 어디서 데이터를 가져올까? (테이블 결합)
  2. **`WHERE`:** 원본 데이터 중 어떤 것만 걸러낼까? (1차 필터링)
  3. **`GROUP BY`:** 필터링된 데이터를 무엇을 기준으로 그룹 지을까?
  4. **`HAVING`:** 그룹 지은 결과(통계값) 중 조건에 맞는 것만 어떻게 다시 걸러낼까? (2차 필터링)
  5. **`SELECT`:** 최종적으로 어떤 열(컬럼)들만 화면에 보여줄까?
  6. **`ORDER BY`:** 나온 결과를 오름차순/내림차순으로 어떻게 정렬할까?

---

### 📝 요약 및 과제

7강에서는 흩어진 로우(데이터)들을 특정 기준으로 묶어 통계를 내는 그룹화(**GROUP BY**)와, 통계 결과에 필터를 거는 **HAVING**의 차이를 명확히 구분했습니다.
그리고 매우 강력한 SQL 실행 순서의 원리까지 파악했습니다.

**🗣 생각해 볼 문제 (마지막 피날레):**
이제 데이터베이스 특강의 최종장에 다다랐습니다. 마지막으로 한 가지만 더 생각해 볼까요?

초롱대학교 수강신청 기간입니다! 김초롱 학생이 '데이터베이스 특강' 수강 버튼을 눌렀고 남은 정원은 1명입니다.
그런데 동시에 이데이터 학생도 같은 과목 수강 버튼을 눌렀습니다. 
**이 두 가지의 등록 작업이 동시에 일어났을 때, 두 명이 모두 수강되어서 정원을 초과해버리거나, 한 명의 신청 과정에서 에러가 났는데 반쪽짜리 처리가 되어버리는 끔찍한 사태(시스템 오류)를 데이터베이스는 어떻게 막아낼까요?**

가장 완벽한 처리를 보장하는 데이터베이스의 이 '안전장치(작업의 논리적 단위)'를 무엇이라고 부를까요?
